<!DOCTYPE html>
<html>
<head>
    <title>T-Maze Beetle Burrow</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&family=Open+Sans:wght@400;600&display=swap');
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #f5e6d3 0%, #e8d5b7 100%);
            font-family: 'Open Sans', sans-serif;
            position: relative;
            overflow: hidden;
        }
        
        body::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                radial-gradient(circle at 20% 50%, rgba(139, 90, 43, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(160, 82, 45, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 20%, rgba(139, 69, 19, 0.08) 0%, transparent 50%);
            pointer-events: none;
        }
        
        #startMenu, #instructionsMenu {
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 50px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(139, 90, 43, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(139, 90, 43, 0.2);
            position: relative;
            z-index: 1;
        }

        #startMenu h1, #instructionsMenu h1 {
            font-family: 'Merriweather', serif;
            color: #5d4037;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        #instructionsMenu p, #instructionsMenu li {
            color: #3e2723;
        }
        
        #startMenu input {
            padding: 12px 20px;
            margin: 20px;
            width: 260px;
            border: 2px solid #8b5a2b;
            border-radius: 8px;
            font-size: 16px;
            background: #faf8f5;
            color: #5d4037;
            transition: all 0.3s ease;
            font-family: 'Open Sans', sans-serif;
        }
        
        #startMenu input:focus {
            outline: none;
            border-color: #6d4c41;
            box-shadow: 0 0 0 3px rgba(139, 90, 43, 0.2);
            transform: translateY(-1px);
        }
        
        #startMenu button {
            padding: 14px 40px;
            font-size: 18px;
            cursor: pointer;
            background: linear-gradient(135deg, #8b5a2b 0%, #6d4c41 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(139, 90, 43, 0.3);
            font-family: 'Open Sans', sans-serif;
            margin-top: 10px;
        }
        
        #startMenu button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(139, 90, 43, 0.4);
            background: linear-gradient(135deg, #a0522d 0%, #8b5a2b 100%);
        }
        
        #startMenu button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(139, 90, 43, 0.3);
        }
        
        canvas {
            border: 4px solid #6d4c41;
            border-radius: 15px;
            cursor: pointer;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
            background: #faf8f5;
            position: relative;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div id="startMenu">
        <h1>Halassa Lab's Beetle Burrow T-Maze</h1>
        <input type="text" id="subjectId" placeholder="Enter Subject ID">
        <button id="startButton">Start Task</button>
        <button id="instructionsButton">Instructions</button>
    </div>

    <div id="instructionsMenu" style="display: none;">
        <h1>Instructions</h1>
        <div style="text-align: left; max-width: 600px; margin-bottom: 20px; line-height: 1.6;">
            <p><strong>Goal:</strong> Your objective is to predict the outcome of a beetle's journey through a maze.</p>
            <p><strong>How it works:</strong></p>
            <ul>
                <li>In each trial, a beetle will start at the bottom of the maze and run upwards.</li>
                <li>At the top, it will turn either left or right before disappearing from view.</li>
                <li>At the end of each arm, there is a predator. Different beetles have different survival rates against different predators.</li>
                <li>The beetle will either be <strong>eaten</strong> by the predator or <strong>escape</strong> past it.</li>
                <li>After the beetle's run, you must click on the area where you believe the trial ended (one of the two escape zones or one of the two predator pockets).</li>
                <li>You will receive immediate feedback on whether your prediction was correct.</li>
            </ul>
            <p>Pay close attention to the beetle type and the predators to learn the patterns and improve your score!</p>
        </div>
        <button id="returnToMenuButton">Return to Main Menu</button>
    </div>

    <canvas id="tMazeCanvas" width="500" height="500" style="display: none;"></canvas>

    <script>
        const canvas = document.getElementById('tMazeCanvas');
        const ctx = canvas.getContext('2d');

        const colors = {
            maze: '#4a3426',             
            mazeHighlight: '#5d4037',     
            background: '#faf8f5',       
            pocketBase: 'rgba(205, 133, 63, 0.3)', 
            text: '#3e2723',             
            buttonBg: '#d7ccc8',        
            buttonHover: '#bcaaa4',      
            buttonText: '#3e2723',        
            correctFeedback: '#689f38',  
            incorrectFeedback: '#d84315', 
            downloadButton: '#6d4c41',    
            shadow: 'rgba(0, 0, 0, 0.2)'
        };

        let gameState = 'menu'; // 'menu', 'start', 'running', 'awaitingInput', 'showingFeedback', 'finished'
        let interstitialMessage = ''; // To hold messages between phases
        let subjectID = '';

        const stemWidth = 40;
        const stemHeight = 100;
        const topHeight = 40;

        const leftArmLength = 150;
        const rightArmLength = 170;
        
        const topWidth = leftArmLength + stemWidth + rightArmLength; 
        const mazeX = (canvas.width - topWidth) / 2 + leftArmLength; 
        const mazeY = (canvas.height - stemHeight - topHeight) / 2;
        const junctionY = mazeY + stemHeight;
        const leftBoundary = (canvas.width - topWidth) / 2;
        const rightBoundary = leftBoundary + topWidth;

        const bugAssets = {
            red_orange_beetle: new Image(),
            blue_beetle: new Image()
        };
        bugAssets.red_orange_beetle.src = 'red_bug.png'; 
        bugAssets.blue_beetle.src = 'blue_bug.png';    

        const predatorAssets = {
            Pink: new Image(),
            Orange: new Image(),
            Yellow: new Image()
        };
        predatorAssets.Pink.src = 'Pink.png';      
        predatorAssets.Orange.src = 'Orange.png';   
        predatorAssets.Yellow.src = 'Yellow.png';   

        const predators = [
            { name: 'Pink', color: '#e91e63', asset: predatorAssets.Pink },
            { name: 'Orange', color: '#ff6f00', asset: predatorAssets.Orange },
            { name: 'Yellow', color: '#fdd835', asset: predatorAssets.Yellow }
        ];
        
        const predationProbabilities = {
            'red_orange_beetle': { 'Pink': 0.2, 'Orange': 0.8, 'Yellow': 0.5 },
            'blue_beetle': { 'Pink': 0.9, 'Orange': 0.3, 'Yellow': 0.6 }
        };

        let leftPredator, rightPredator;
        const pocketRadius = 35;
        const pocketY = junctionY + topHeight; 
        const pocketColor = colors.pocketBase;
        const leftPocketCenterX = mazeX - pocketRadius; 
        const rightPocketCenterX = mazeX + stemWidth + pocketRadius; 

        // Danger Zones (directly above pockets)
        const leftDangerZone = { start: leftPocketCenterX - pocketRadius, end: leftPocketCenterX + pocketRadius };
        const rightDangerZone = { start: rightPocketCenterX - pocketRadius, end: rightPocketCenterX + pocketRadius };
        
        let bug = {
            x: mazeX + (stemWidth / 2),
            y: mazeY,
            width: 30,
            height: 40,
            type: 'red_orange_beetle', 
            speed: 1.5,
            normalSpeed: 1.5,
            fastSpeed: 3,
            visible: true,
            direction: null,
            actualOutcome: null,
            isInDangerZone: false
        };

        // Audio parameters
        let audioContext, oscillator, gainNode, biquadFilter;
        let isAudioInitialized = false;

        // Trial parameters
        let trialCount = 0;
        let currentPhase = 1; // 1: First bug type, 2: Second bug type, 3: Mixed
        let firstBugType = null; 
        let secondBugType = null; 
        let feedbackMessage = '';
        let trialData = []; 
        let responseTimer = null;
        const RESPONSE_TIME_LIMIT = 5000;

        const exitZoneWidth = 60;
        const clickableZones = {
            'escaped-left': { x: leftBoundary, y: junctionY, width: exitZoneWidth, height: topHeight },
            'eaten-left': { x: leftPocketCenterX - pocketRadius, y: pocketY - pocketRadius, width: pocketRadius * 2, height: pocketRadius * 2 },
            'escaped-right': { x: rightBoundary - exitZoneWidth, y: junctionY, width: exitZoneWidth, height: topHeight },
            'eaten-right': { x: rightPocketCenterX - pocketRadius, y: pocketY - pocketRadius, width: pocketRadius * 2, height: pocketRadius * 2 }
        };
        
        const downloadBtn = {
            x: (canvas.width - 120) / 2,
            y: canvas.height / 2 + 40,
            width: 120,
            height: 40,
            label: 'Download CSV'
        };

        function getRandomPredator() {
            return predators[Math.floor(Math.random() * predators.length)];
        }
        
        // --- DRAWING FUNCTIONS ---
        function drawTMaze() {

            ctx.save();

            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, colors.mazeHighlight);
            gradient.addColorStop(1, colors.maze);
            ctx.fillStyle = gradient;

            ctx.fillRect(mazeX, mazeY, stemWidth, stemHeight);
            
            ctx.fillRect(leftBoundary, junctionY, topWidth, topHeight);
            
            ctx.globalAlpha = 0.1;
            ctx.strokeStyle = colors.maze;
            ctx.lineWidth = 1;
            
            for (let i = 0; i < 10; i++) {
                ctx.beginPath();
                ctx.moveTo(mazeX + Math.random() * stemWidth, mazeY);
                ctx.lineTo(mazeX + Math.random() * stemWidth, mazeY + stemHeight);
                ctx.stroke();
            }
            
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.moveTo(leftBoundary, junctionY + Math.random() * topHeight);
                ctx.lineTo(rightBoundary, junctionY + Math.random() * topHeight);
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1.0;
            ctx.restore();
        }
        
        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        function drawPredatorPockets() {
            if (!leftPredator || !rightPredator) return;

            const drawPocketWithPredator = (centerX, predator) => {
                const pocketGradient = ctx.createRadialGradient(centerX, pocketY, 0, centerX, pocketY, pocketRadius);
                pocketGradient.addColorStop(0, 'rgba(205, 133, 63, 0.4)');
                pocketGradient.addColorStop(1, 'rgba(139, 90, 43, 0.2)');
                ctx.fillStyle = pocketGradient;
                ctx.beginPath();
                ctx.arc(centerX, pocketY, pocketRadius, 0, Math.PI, false);
                ctx.fill();
                
                ctx.strokeStyle = 'rgba(139, 90, 43, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();

                const asset = predator.asset;
                const predatorImgWidth = 20;
                const predatorImgHeight = 40;
                
                if (asset && asset.complete && asset.naturalHeight !== 0) {
                    ctx.save();
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                    ctx.shadowBlur = 5;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;

                    const visualY = pocketY + pocketRadius / 2;
                    const drawX = centerX - predatorImgWidth / 2;
                    const drawY = visualY - predatorImgHeight / 2;

                    ctx.drawImage(asset, drawX, drawY, predatorImgWidth, predatorImgHeight);
                    ctx.restore();
                }
            };

            drawPocketWithPredator(leftPocketCenterX, leftPredator);
            drawPocketWithPredator(rightPocketCenterX, rightPredator);
        }
        
        function adjustColor(color, amount) {
            const usePound = color[0] === '#';
            const col = usePound ? color.slice(1) : color;
            const num = parseInt(col, 16);
            const r = Math.max(0, Math.min(255, (num >> 16) + amount));
            const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amount));
            const b = Math.max(0, Math.min(255, (num & 0x0000FF) + amount));
            return (usePound ? '#' : '') + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
        }

        function drawBug() {
            if (bug.visible) {
                const asset = bugAssets[bug.type];
                if (asset && asset.complete && asset.naturalHeight !== 0) {
                    ctx.save();
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.shadowBlur = 4;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                    ctx.drawImage(asset, bug.x - bug.width / 2, bug.y - bug.height / 2, bug.width, bug.height);
                    ctx.restore();
                } else {
                    ctx.fillStyle = 'grey';
                    ctx.fillRect(bug.x - bug.width / 2, bug.y - bug.height / 2, bug.width, bug.height);
                }
            }
        }

        function drawUI() {
            ctx.fillStyle = colors.text;
            ctx.font = '600 16px "Open Sans", sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`Trial: ${trialCount + 1} (Phase: ${currentPhase})`, 20, 30);

            if (gameState === 'start') {
                ctx.font = '700 24px "Merriweather", serif';
                ctx.textAlign = 'center';
                ctx.fillStyle = colors.text;
                ctx.fillText('Click to Start Simulation', canvas.width / 2, canvas.height / 2);
            
            } else if (gameState === 'interstitial') {
                // Draw a semi-transparent overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw the popup box
                const boxWidth = 400;
                const boxHeight = 150;
                const boxX = (canvas.width - boxWidth) / 2;
                const boxY = (canvas.height - boxHeight) / 2;
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
                ctx.strokeStyle = colors.mazeHighlight;
                ctx.lineWidth = 3;
                roundRect(ctx, boxX, boxY, boxWidth, boxHeight, 15);
                ctx.fill();
                ctx.stroke();

                // Draw the message text
                ctx.font = '700 22px "Merriweather", serif';
                ctx.textAlign = 'center';
                ctx.fillStyle = colors.text;
                ctx.fillText(interstitialMessage, canvas.width / 2, boxY + 60);

                ctx.font = '400 16px "Open Sans", sans-serif';
                ctx.fillText('Click anywhere to continue.', canvas.width / 2, boxY + 110);

            } else if (gameState === 'awaitingInput') {
                ctx.font = '600 18px "Open Sans", sans-serif';
                ctx.textAlign = 'center';
                ctx.fillStyle = colors.text;
                ctx.fillText('What was the outcome? Click the area.', canvas.width / 2, mazeY - 30);
                
                ctx.save();
                ctx.globalAlpha = 0.35;
                
                ctx.fillStyle = '#3498db';
                const leftExit = clickableZones['escaped-left'];
                ctx.fillRect(leftExit.x, leftExit.y, leftExit.width, leftExit.height);
                const rightExit = clickableZones['escaped-right'];
                ctx.fillRect(rightExit.x, rightExit.y, rightExit.width, rightExit.height);

                ctx.fillStyle = '#e74c3c'; 
                const leftPocket = clickableZones['eaten-left'];
                ctx.beginPath();
                ctx.arc(leftPocket.x + pocketRadius, leftPocket.y + pocketRadius, pocketRadius, 0, Math.PI, false);
                ctx.fill();
                const rightPocket = clickableZones['eaten-right'];
                ctx.beginPath();
                ctx.arc(rightPocket.x + pocketRadius, rightPocket.y + pocketRadius, pocketRadius, 0, Math.PI, false);
                ctx.fill();

                ctx.restore();

                        } else if (gameState === 'showingFeedback') {
                ctx.font = '700 24px "Merriweather", serif';
                ctx.textAlign = 'center';
                ctx.fillStyle = feedbackMessage === 'Correct!' ? colors.correctFeedback : colors.incorrectFeedback;
                ctx.fillText(feedbackMessage, canvas.width / 2, mazeY - 30);

                if (feedbackMessage !== 'Miss') {
                    const correctZoneKey = bug.actualOutcome;
                    if (correctZoneKey && clickableZones[correctZoneKey]) {
                        const zone = clickableZones[correctZoneKey];
                        
                        ctx.save();
                        ctx.globalAlpha = 0.5;
                        ctx.fillStyle = colors.correctFeedback; 

                        if (correctZoneKey.startsWith('escaped')) {
                            ctx.fillRect(zone.x, zone.y, zone.width, zone.height);
                        } else {
                            ctx.beginPath();
                            ctx.arc(zone.x + pocketRadius, zone.y + pocketRadius, pocketRadius, 0, Math.PI, false);
                            ctx.fill();
                        }
                        ctx.restore();
                    }
                }

            } else if (gameState === 'finished') {
                ctx.font = '700 24px "Merriweather", serif';
                ctx.textAlign = 'center';
                ctx.fillStyle = colors.text;
                ctx.fillText('Thank You!', canvas.width / 2, canvas.height / 2);
                
                ctx.save();
                ctx.shadowColor = colors.shadow;
                ctx.shadowBlur = 6;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;
                
                const dlGradient = ctx.createLinearGradient(downloadBtn.x, downloadBtn.y, downloadBtn.x, downloadBtn.y + downloadBtn.height);
                dlGradient.addColorStop(0, colors.downloadButton);
                dlGradient.addColorStop(1, adjustColor(colors.downloadButton, -20));
                ctx.fillStyle = dlGradient;
                roundRect(ctx, downloadBtn.x, downloadBtn.y, downloadBtn.width, downloadBtn.height, 5);
                ctx.fill();
                ctx.restore();
                
                ctx.fillStyle = 'white';
                ctx.font = '600 16px "Open Sans", sans-serif';
                ctx.fillText(downloadBtn.label, downloadBtn.x + downloadBtn.width / 2, downloadBtn.y + downloadBtn.height / 2 + 5);
            }
        }

        // --- AUDIO FUNCTIONS ---
        function setupAudio() {
            if (isAudioInitialized) return;
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            gainNode = audioContext.createGain();
            biquadFilter = audioContext.createBiquadFilter();
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            biquadFilter.connect(gainNode).connect(audioContext.destination);
            isAudioInitialized = true;
        }

        function playTone() {
            if (!isAudioInitialized) return;
            oscillator = audioContext.createOscillator();
            oscillator.type = 'sawtooth';
            oscillator.connect(biquadFilter);
            oscillator.start();
            updateAudio();
        }

        function stopTone() {
            if (oscillator) oscillator.stop();
        }

        function updateAudio() {
            if (!isAudioInitialized || !oscillator) return;
            const freq = bug.speed * 100 + 150;
            oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);

            if (bug.isInDangerZone) {
                biquadFilter.type = 'highpass';
                biquadFilter.frequency.setValueAtTime(1200, audioContext.currentTime);
            } else {
                biquadFilter.type = 'lowpass';
                biquadFilter.frequency.setValueAtTime(500, audioContext.currentTime);
            }
        }

        function update() {
            if (gameState !== 'running') return;

            // State 1: Move up the stem
            if (bug.direction === null) {
                if (bug.y < junctionY + topHeight / 2) {
                    bug.y += bug.speed;
                } else { 
                    bug.y = junctionY + topHeight / 2;
                    bug.visible = false;
                    bug.direction = Math.random() < 0.5 ? 'left' : 'right';
                    
                    const predator = bug.direction === 'left' ? leftPredator : rightPredator;
                    const probability = predationProbabilities[bug.type][predator.name];

                    if (Math.random() < probability) {
                        bug.actualOutcome = `eaten-${bug.direction}`;
                    } else {
                        bug.actualOutcome = `escaped-${bug.direction}`;
                    }
                }
            } else { 
                const wasInDangerZone = bug.isInDangerZone;
                const inLeftZone = bug.direction === 'left' && bug.x < leftDangerZone.end && bug.x > leftDangerZone.start;
                const inRightZone = bug.direction === 'right' && bug.x > rightDangerZone.start && bug.x < rightDangerZone.end;
                bug.isInDangerZone = inLeftZone || inRightZone;

                if (wasInDangerZone !== bug.isInDangerZone) {
                    bug.speed = bug.isInDangerZone ? bug.fastSpeed : bug.normalSpeed;
                    updateAudio();
                }

                bug.x += (bug.direction === 'left' ? -1 : 1) * bug.speed;

                if (bug.actualOutcome.startsWith('eaten')) {
                    const stopX = bug.direction === 'left' ? leftPocketCenterX : rightPocketCenterX;
                    if ((bug.direction === 'left' && bug.x <= stopX) || (bug.direction === 'right' && bug.x >= stopX)) {
                        bug.x = stopX; 
                        endTrial();
                    }
                } else if (bug.x < leftBoundary || bug.x > rightBoundary) {
                    endTrial();
                }
            }
        }
        
        function endTrial() {
            bug.speed = 0; 
            stopTone();
            gameState = 'awaitingInput';
            
            responseTimer = setTimeout(handleMiss, RESPONSE_TIME_LIMIT);
        }

        function handleMiss() {
            if (gameState !== 'awaitingInput') return; 

            feedbackMessage = 'Miss';

            trialData.push({
                trial: trialCount + 1,
                phase: currentPhase,
                bugType: bug.type, 
                leftPredatorName: leftPredator.name, 
                rightPredatorName: rightPredator.name, 
                bugDirection: bug.direction,
                actualOutcome: bug.actualOutcome,
                userChoice: 'miss', 
                correct: false,
                subjectID: subjectID
            });

            gameState = 'showingFeedback';
            trialCount++; 

            setTimeout(() => {
                advanceToNextTrial();
            }, 1500);
        }

        function checkPerformanceAndAdvance() {
            // Performance check does not apply to phase 4 (fixed trials)
            if (currentPhase >= 4) {
                return false;
            }

            const phaseTrials = trialData.filter(t => t.phase === currentPhase);
            if (phaseTrials.length < 10) {
                return false;
            }

            const lastTenPhaseTrials = phaseTrials.slice(-10);
            const correctCount = lastTenPhaseTrials.filter(t => t.correct).length;

            if (correctCount >= 6) {
                // Advance from Phase 1 to 2
                if (currentPhase === 1) {
                    currentPhase = 2;
                    interstitialMessage = "A new bug has entered the tree!";
                    gameState = 'interstitial';
                    console.log(`Performance criterion met. Advancing to phase 2.`);
                    return true;
                // Advance from Phase 2 to 3
                } else if (currentPhase === 2) {
                    currentPhase = 3;
                    interstitialMessage = "This tree has both of the bugs in it!";
                    gameState = 'interstitial';
                    console.log(`Performance criterion met. Advancing to phase 3.`);
                    return true;
                // Advance from Phase 3 to 4 (final phase)
                } else if (currentPhase === 3) {
                    currentPhase = 4;
                    interstitialMessage = "Training complete; let's try a full run now!";
                    gameState = 'interstitial';
                    console.log(`Performance criterion met. Advancing to final phase 4.`);
                    return true;
                }
            }
            return false;
        }

        function advanceToNextTrial() {
            // First, check if the last trial's performance allows advancement
            const advanced = checkPerformanceAndAdvance();

            // If we did not advance to an interstitial state, set up the next trial immediately.
            if (!advanced) {
                setupNextTrial();
            }
        }

        function setupNextTrial() {
            // Check if phase 4 (fixed 40 trials) is complete
            if (currentPhase === 4) {
                const phase4Trials = trialData.filter(t => t.phase === 4);
                if (phase4Trials.length >= 40) {
                    gameState = 'finished';
                    console.log("Final phase of 40 trials complete. Simulation finished.");
                    saveDataToGoogleSheet(); // Save data at the very end
                    return;
                }
            }
            
            // Set bug type based on the current phase
            if (currentPhase === 1) {
                bug.type = firstBugType;
            } else if (currentPhase === 2) {
                bug.type = secondBugType;
            } else { // Phases 3 and 4 are mixed blocks
                bug.type = Math.random() < 0.5 ? 'red_orange_beetle' : 'blue_beetle';
            }

            leftPredator = getRandomPredator();
            do {
                rightPredator = getRandomPredator();
            } while (rightPredator.name === leftPredator.name);

            bug.x = mazeX + (stemWidth / 2);
            bug.y = mazeY;
            bug.visible = true;
            bug.direction = null;
            bug.actualOutcome = null;
            bug.isInDangerZone = false;
            bug.speed = bug.normalSpeed;
            
            gameState = 'running';
            playTone();
        }

        function handleChoice(chosenOutcome) {
            if (gameState !== 'awaitingInput') return;

            clearTimeout(responseTimer);

            const isCorrect = chosenOutcome === bug.actualOutcome;
            feedbackMessage = isCorrect ? 'Correct!' : 'Incorrect!';
            
            trialData.push({
                trial: trialCount + 1,
                phase: currentPhase,
                bugType: bug.type, 
                leftPredatorName: leftPredator.name, 
                rightPredatorName: rightPredator.name, 
                bugDirection: bug.direction,
                actualOutcome: bug.actualOutcome,
                userChoice: chosenOutcome,
                correct: isCorrect,
                subjectID: subjectID
            });

            gameState = 'showingFeedback';
            trialCount++; 

            setTimeout(() => {
                advanceToNextTrial();
            }, 1500);
        }

        function saveDataToGoogleSheet() {
            console.log("Preparing to save all trial data in a single batch...");
            const googleWebAppUrl = 'https://script.google.com/macros/s/AKfycby0S7BEsX-RPEmyYshMMlXMwp2DzaNFk8hXUgxToVyNGyoD-a88nmWRne5gacOZ9_2v/exec';

            if (trialData.length === 0) {
                console.log("No data to save.");
                return;
            }

            fetch(googleWebAppUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'text/plain;charset=utf-8',
                },
                body: JSON.stringify(trialData) 
            })
            .then(response => response.json())
            .then(data => {
                if (data.result === 'success') {
                    console.log(`Successfully saved ${data.rowsAdded} trials to the Google Sheet.`);
                } else {
                    console.error('Error saving data to Google Sheet:', data.error);
                }
            })
            .catch(error => {
                console.error('Fetch Error:', error);
            });
        }
        
        function exportToCSV() {
            if (trialData.length === 0) {
                console.log("No data to export.");
                return;
            }

            const headers = ['Subject_ID', 'Trial', 'Phase', 'Bug_Type', 'Left_Predator', 'Right_Predator', 'Bug_Direction', 'Actual_Outcome', 'User_Choice', 'Correct'];
            const csvRows = [headers.join(',')];

            trialData.forEach(data => {
                const values = [
                    data.subjectID,
                    data.trial,
                    data.phase,
                    data.bugType,
                    data.leftPredatorName,
                    data.rightPredatorName,
                    data.bugDirection,
                    data.actualOutcome,
                    data.userChoice,
                    data.correct
                ];
                csvRows.push(values.join(','));
            });

            const csvString = csvRows.join('\n');
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });

            const link = document.createElement('a');
            if (link.download !== undefined) {
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                const dateTime = `${year}${month}${day}_${hours}${minutes}${seconds}`;
                const filename = `t-maze-beetle-burrow_${subjectID}_${dateTime}.csv`;

                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename); 
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        function gameLoop() {
            update();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawTMaze();
            drawPredatorPockets();
            drawBug();
            drawUI();

            requestAnimationFrame(gameLoop);
        }

        function handleClick(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            if (gameState === 'start') {
                setupAudio();
                if (audioContext.state === 'suspended') audioContext.resume();
                
                if (Math.random() < 0.5) {
                    firstBugType = 'red_orange_beetle';
                    secondBugType = 'blue_beetle';
                } else {
                    firstBugType = 'blue_beetle';
                    secondBugType = 'red_orange_beetle';
                }

                setupNextTrial();
                return;
            }

            if (gameState === 'interstitial') {
                // When the interstitial message is shown, a click anywhere continues to the next trial
                setupNextTrial();
                return;
            }

            if (gameState === 'awaitingInput') {
                for (const outcome in clickableZones) {
                    const zone = clickableZones[outcome];
                    if (x > zone.x && x < zone.x + zone.width && y > zone.y && y < zone.y + zone.height) {
                        handleChoice(outcome);
                        return; 
                    }
                }
                } else if (gameState === 'finished') {
                if (x > downloadBtn.x && x < downloadBtn.x + downloadBtn.width && y > downloadBtn.y && y < downloadBtn.y + downloadBtn.height) {
                    exportToCSV();
                    }
            }
        }
        
        function startTask() {
            const idInput = document.getElementById('subjectId');
            subjectID = idInput.value.trim();
            if (subjectID === "") {
                alert("Please enter a Subject ID to start.");
                return;
            }

            document.getElementById('startMenu').style.display = 'none';
            canvas.style.display = 'block';
            
            gameState = 'start'; 
        }

        function showInstructions() {
            document.getElementById('startMenu').style.display = 'none';
            document.getElementById('instructionsMenu').style.display = 'block';
        }

        function returnToMainMenu() {
            document.getElementById('instructionsMenu').style.display = 'none';
            document.getElementById('startMenu').style.display = 'block';
        }

        document.getElementById('startButton').addEventListener('click', startTask);
        document.getElementById('instructionsButton').addEventListener('click', showInstructions);
        document.getElementById('returnToMenuButton').addEventListener('click', returnToMainMenu);
        canvas.addEventListener('click', handleClick);

        gameLoop();  

    </script>
</body>
</html>